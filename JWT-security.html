<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JWT Security Guide - JavaScript Security</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <style>
        /* Layout System - Consistent with all pages */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            color: #333;
                    background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        header {
            background: linear-gradient(to right, #2c3e50, #4a6491);
            color: white;
            padding: 2rem;
            border-radius: 10px;
            margin-bottom: 2rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
        h1 {
            font-size: 2.5rem;
            margin-bottom: 0.5rem;
        }
        
        .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            margin-bottom: 1.5rem;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 1rem;
        }
        
        .logo-img {
            width: 40px;
            height: 40px;
            background: white;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: #2c3e50;
        }
        
        .content-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 2rem;
            margin-bottom: 3rem;
        }
        
        @media (max-width: 768px) {
            .content-grid {
                grid-template-columns: 1fr;
            }
        }
        
        .card {
            background: white;
            border-radius: 10px;
            padding: 1.5rem;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
            transition: transform 0.3s ease;
        }
        
        .card:hover {
            transform: translateY(-5px);
        }
        
        .card-title {
            color: #2c3e50;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid;
            font-size: 1.3rem;
        }
        
        .card-title.intro { border-bottom-color: #ff6b6b; }
        .card-title.structure { border-bottom-color: #4ecdc4; }
        .card-title.security { border-bottom-color: #45b7d1; }
        .card-title.implementation { border-bottom-color: #96ceb4; }
        .card-title.best { border-bottom-color: #feca57; }
        .card-title.alternatives { border-bottom-color: #5f27cd; }
        
        .code-block {
            background: #2d2d2d;
            color: #f8f8f2;
            border-radius: 5px;
            padding: 1rem;
            overflow-x: auto;
            margin: 1rem 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
        }
        
        .warning {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 1rem;
            border-radius: 5px;
            margin: 1rem 0;
            font-size: 0.95rem;
        }
        
        .info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
            padding: 1rem;
            border-radius: 5px;
            margin: 1rem 0;
            font-size: 0.95rem;
        }
        
        .danger {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
            padding: 1rem;
            border-radius: 5px;
            margin: 1rem 0;
            font-size: 0.95rem;
        }
        
        .success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
            padding: 1rem;
            border-radius: 5px;
            margin: 1rem 0;
            font-size: 0.95rem;
        }
        
        .comparison-table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }
        
        .comparison-table th {
            background: #4a6491;
            color: white;
            padding: 1rem;
            text-align: left;
            font-weight: 600;
        }
        
        .comparison-table td {
            padding: 1rem;
            border-bottom: 1px solid #dee2e6;
        }
        
        .comparison-table tr:hover {
            background: #f8f9fa;
        }
        
        .step-list {
            margin-left: 1.5rem;
            margin-bottom: 1.5rem;
        }
        
        .step-list li {
            margin-bottom: 0.5rem;
        }
        
        .demo-area {
            background: white;
            padding: 2rem;
            border-radius: 10px;
            margin: 2rem 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
        }
        
        .jwt-visualization {
            background: #f8f9fa;
            padding: 1.5rem;
            border-radius: 8px;
            margin: 1rem 0;
            font-family: 'Courier New', monospace;
            overflow-x: auto;
        }
        
        .jwt-part {
            margin-bottom: 0.5rem;
            padding: 0.5rem;
            border-radius: 4px;
        }
        
        .jwt-header { background: #ff6b6b20; border-left: 3px solid #ff6b6b; }
        .jwt-payload { background: #4ecdc420; border-left: 3px solid #4ecdc4; }
        .jwt-signature { background: #45b7d120; border-left: 3px solid #45b7d1; }
        
        footer {
            text-align: center;
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid #dee2e6;
            color: #6c757d;
            font-size: 0.9rem;
        }
    </style>
</head>
<body>
    <div class="container">
        <header>            
            <h1>JWT Security Guide</h1>
            <p class="subtitle">JSON Web Tokens: Stateless Authentication Security</p>
        </header>
        
        <!-- Introduction -->
        <div class="card">
            <h2 class="card-title intro">What is JWT?</h2>
            <p>JSON Web Tokens (JWT) are a compact, URL-safe means of representing claims to be transferred between two parties. They are commonly used for stateless authentication in modern web applications.</p>
            
            <div class="jwt-visualization">
                <div class="jwt-part jwt-header">
                    <strong>Header</strong> (Base64URL encoded)<br>
                    <small>{"alg":"HS256","typ":"JWT"}</small>
                </div>
                <div class="jwt-part jwt-payload">
                    <strong>Payload</strong> (Base64URL encoded)<br>
                    <small>{"sub":"1234567890","name":"John Doe","iat":1516239022}</small>
                </div>
                <div class="jwt-part jwt-signature">
                    <strong>Signature</strong><br>
                    <small>HMACSHA256(base64UrlEncode(header) + "." + base64UrlEncode(payload), secret)</small>
                </div>
            </div>
            
            <div class="info">
                <strong>Format:</strong> <code>header.payload.signature</code><br>
                <strong>Example:</strong> <code>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</code>
            </div>
        </div>
        
        <!-- Complete JWT Implementation -->
        <div class="card">
            <h2 class="card-title implementation">Complete JWT Implementation</h2>
            
            <h4>Secure JWT Service:</h4>
            <div class="code-block">
// jwt-service.js - Complete JWT implementation
const jwt = require('jsonwebtoken');
const crypto = require('crypto');

class JWTService {
  constructor() {
    // Use different keys for access and refresh tokens
    this.accessTokenSecret = process.env.JWT_ACCESS_SECRET || 
                             crypto.randomBytes(32).toString('hex');
    this.refreshTokenSecret = process.env.JWT_REFRESH_SECRET || 
                              crypto.randomBytes(32).toString('hex');
    
    // Token blacklist for logout (simplified - use Redis in production)
    this.tokenBlacklist = new Set();
  }
  
  // Generate access token (short-lived)
  generateAccessToken(user) {
    return jwt.sign(
      {
        sub: user.id,
        email: user.email,
        role: user.role,
        // JWT ID for individual token invalidation
        jti: crypto.randomBytes(16).toString('hex'),
        type: 'access'
      },
      this.accessTokenSecret,
      {
        expiresIn: '15m', // Short expiration
        issuer: 'your-app-name',
        audience: 'your-app-users'
      }
    );
  }
  
  // Generate refresh token (longer-lived, stored server-side)
  generateRefreshToken(user) {
    const refreshToken = jwt.sign(
      {
        sub: user.id,
        jti: crypto.randomBytes(16).toString('hex'),
        type: 'refresh'
      },
      this.refreshTokenSecret,
      {
        expiresIn: '7d',
        issuer: 'your-app-name'
      }
    );
    
    // Store refresh token in database with metadata
    this.storeRefreshToken(user.id, refreshToken);
    
    return refreshToken;
  }
  
  // Verify access token
  verifyAccessToken(token) {
    try {
      const decoded = jwt.verify(token, this.accessTokenSecret, {
        issuer: 'your-app-name',
        audience: 'your-app-users'
      });
      
      // Check if token is blacklisted
      if (this.tokenBlacklist.has(decoded.jti)) {
        throw new Error('Token has been revoked');
      }
      
      return { valid: true, payload: decoded };
    } catch (error) {
      return { valid: false, error: error.message };
    }
  }
  
  // Refresh token rotation
  refreshTokens(oldRefreshToken) {
    try {
      // Verify old refresh token
      const decoded = jwt.verify(oldRefreshToken, this.refreshTokenSecret);
      
      // Check if refresh token is valid in database
      if (!this.isValidRefreshToken(decoded.jti)) {
        throw new Error('Refresh token invalid or revoked');
      }
      
      // Get user from database
      const user = this.getUserById(decoded.sub);
      
      // Generate new tokens
      const newAccessToken = this.generateAccessToken(user);
      const newRefreshToken = this.generateRefreshToken(user);
      
      // Invalidate old refresh token
      this.invalidateRefreshToken(decoded.jti);
      
      return {
        accessToken: newAccessToken,
        refreshToken: newRefreshToken
      };
    } catch (error) {
      throw new Error(`Token refresh failed: ${error.message}`);
    }
  }
  
  // Logout - add token to blacklist
  logout(accessTokenJti, refreshTokenJti) {
    if (accessTokenJti) {
      this.tokenBlacklist.add(accessTokenJti);
    }
    if (refreshTokenJti) {
      this.invalidateRefreshToken(refreshTokenJti);
    }
  }
  
  // Store refresh token in database
  async storeRefreshToken(userId, token) {
    const decoded = jwt.decode(token);
    
    // Store in database with metadata
    await db.refreshTokens.create({
      jti: decoded.jti,
      userId: userId,
      token: token,
      expiresAt: new Date(decoded.exp * 1000),
      userAgent: this.currentUserAgent,
      ipAddress: this.currentIp,
      createdAt: new Date()
    });
  }
  
  // Check if refresh token is valid
  async isValidRefreshToken(jti) {
    const tokenRecord = await db.refreshTokens.findOne({ where: { jti } });
    return tokenRecord && tokenRecord.isActive && 
           new Date() < tokenRecord.expiresAt;
  }
  
  // Invalidate refresh token
  async invalidateRefreshToken(jti) {
    await db.refreshTokens.update(
      { isActive: false, revokedAt: new Date() },
      { where: { jti } }
    );
  }
}

module.exports = new JWTService();
            </div>
            
            <h4>Express.js Integration with JWT:</h4>
            <div class="code-block">
// auth-middleware.js - JWT authentication
const jwtService = require('./jwt-service');

function authenticateToken(req, res, next) {
  // Get token from Authorization header
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1]; // Bearer TOKEN
  
  if (!token) {
    return res.status(401).json({ error: 'Access token required' });
  }
  
  // Verify token
  const result = jwtService.verifyAccessToken(token);
  
  if (!result.valid) {
    return res.status(403).json({ 
      error: 'Invalid token', 
      details: result.error 
    });
  }
  
  // Attach user to request
  req.user = result.payload;
  req.token = token;
  next();
}

// Refresh token endpoint
app.post('/api/auth/refresh', async (req, res) => {
  const { refreshToken } = req.body;
  
  if (!refreshToken) {
    return res.status(400).json({ error: 'Refresh token required' });
  }
  
  try {
    const tokens = await jwtService.refreshTokens(refreshToken);
    
    res.json({
      accessToken: tokens.accessToken,
      refreshToken: tokens.refreshToken,
      expiresIn: 900 // 15 minutes in seconds
    });
  } catch (error) {
    res.status(403).json({ error: error.message });
  }
});

// Login endpoint with JWT
app.post('/api/auth/login', async (req, res) => {
  const { email, password } = req.body;
  
  // Validate credentials
  const user = await validateUserCredentials(email, password);
  
  if (!user) {
    return res.status(401).json({ error: 'Invalid credentials' });
  }
  
  // Generate tokens
  const accessToken = jwtService.generateAccessToken(user);
  const refreshToken = jwtService.generateRefreshToken(user);
  
  // Set refresh token as HttpOnly cookie
  res.cookie('refreshToken', refreshToken, {
    httpOnly: true,
    secure: process.env.NODE_ENV === 'production',
    sameSite: 'strict',
    maxAge: 7 * 24 * 60 * 60 * 1000 // 7 days
  });
  
  res.json({
    accessToken,
    user: {
      id: user.id,
      email: user.email,
      role: user.role
    }
  });
});

// Protected route
app.get('/api/profile', authenticateToken, (req, res) => {
  res.json({
    user: req.user,
    message: 'Access granted to protected route'
  });
});

// Logout endpoint
app.post('/api/auth/logout', authenticateToken, (req, res) => {
  // Add current access token to blacklist
  jwtService.logout(req.user.jti, req.body.refreshTokenJti);
  
  // Clear refresh token cookie
  res.clearCookie('refreshToken');
  
  res.json({ message: 'Logged out successfully' });
});
            </div>
        </div>
        
        <!-- JWT vs Sessions Comparison -->
        <div class="demo-area">
            <h3>üîÑ JWT vs Traditional Sessions Comparison</h3>
            
            <table class="comparison-table">
                <thead>
                    <tr>
                        <th>Criteria</th>
                        <th>Traditional Sessions</th>
                        <th>JWT (Stateless)</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>State Management</strong></td>
                        <td>Stateful (server stores session data)</td>
                        <td>Stateless (token contains claims)</td>
                    </tr>
                    <tr>
                        <td><strong>Scalability</strong></td>
                        <td>Requires session sharing/sticky sessions</td>
                        <td>Horizontally scalable</td>
                    </tr>
                    <tr>
                        <td><strong>Performance</strong></td>
                        <td>Database lookups for each request</td>
                        <td>Fast verification (cryptographic only)</td>
                    </tr>
                    <tr>
                        <td><strong>Logout/Revocation</strong></td>
                        <td>Easy (delete session from store)</td>
                        <td>Complex (requires token blacklist)</td>
                    </tr>
                    <tr>
                        <td><strong>Token Size</strong></td>
                        <td>Small (session ID only)</td>
                        <td>Larger (contains claims)</td>
                    </tr>
                    <tr>
                        <td><strong>Security</strong></td>
                        <td>Server-side control</td>
                        <td>Client-side storage concerns</td>
                    </tr>
                </tbody>
            </table>
            
            <div class="info" style="margin-top: 1rem;">
                <strong>When to Use Which:</strong><br>
                ‚Ä¢ <strong>Use Sessions:</strong> When you need immediate logout, have sensitive data, or use server-side rendering<br>
                ‚Ä¢ <strong>Use JWT:</strong> For stateless APIs, microservices, mobile apps, or when horizontal scaling is critical
            </div>
        </div>
        
        <!-- Security Best Practices -->
        <div class="card">
            <h2 class="card-title security">JWT Security Best Practices</h2>
            
            <div class="warning">
                <strong>‚ö†Ô∏è Common JWT Security Mistakes:</strong>
                <ul style="margin-top: 0.5rem;">
                    <li>Storing sensitive data in payload (can be decoded by anyone)</li>
                    <li>Using weak signing algorithms (HS256 with weak secret)</li>
                    <li>No token expiration or very long expiration</li>
                    <li>Storing tokens in localStorage (vulnerable to XSS)</li>
                    <li>No refresh token rotation</li>
                    <li>Accepting unsigned tokens (algorithm: none attack)</li>
                </ul>
            </div>
            
            <h4>Secure JWT Implementation Checklist:</h4>
            
            <div class="code-block">
// ‚úÖ SECURE JWT CONFIGURATION

// 1. Use strong signing algorithms
const token = jwt.sign(payload, secret, {
  algorithm: 'HS256', // Or RS256 for public/private key
  // NEVER use 'none'
});

// 2. Set reasonable expiration times
const accessToken = jwt.sign(payload, secret, {
  expiresIn: '15m', // Short-lived access token
});

const refreshToken = jwt.sign(refreshPayload, refreshSecret, {
  expiresIn: '7d', // Longer-lived refresh token
});

// 3. Include JWT ID for individual token invalidation
const payload = {
  sub: userId,
  jti: crypto.randomBytes(16).toString('hex'), // Unique token ID
  iat: Math.floor(Date.now() / 1000),
  exp: Math.floor(Date.now() / 1000) + (15 * 60) // 15 minutes
};

// 4. Validate issuer and audience
jwt.verify(token, secret, {
  issuer: 'your-app-name',
  audience: 'your-app-users',
  algorithms: ['HS256'] // Whitelist allowed algorithms
});

// 5. Store tokens securely
// Access token: Memory or secure cookie
// Refresh token: HttpOnly, Secure, SameSite cookie
            </div>
            
            <h4>Token Storage Security:</h4>
            <div class="code-block">
// ‚ùå INSECURE - Storing in localStorage
localStorage.setItem('token', jwtToken);
// Vulnerable to XSS attacks

// ‚ùå INSECURE - Storing in sessionStorage
sessionStorage.setItem('token', jwtToken);
// Also vulnerable to XSS, cleared on tab close

// ‚úÖ SECURE - Using HttpOnly cookies
res.cookie('refreshToken', refreshToken, {
  httpOnly: true,    // Cannot be accessed by JavaScript
  secure: true,      // HTTPS only
  sameSite: 'strict', // CSRF protection
  maxAge: 7 * 24 * 60 * 60 * 1000
});

// ‚úÖ ACCEPTABLE - Memory storage (Single Page Apps)
let accessToken = null; // Store in memory
// Cleared when page refreshes, vulnerable to XSS but
// better than localStorage

// ‚úÖ BEST PRACTICE - Hybrid approach
// - Access token: Memory or Authorization header
// - Refresh token: HttpOnly cookie
            </div>
        </div>
        
        <!-- Common JWT Attacks & Prevention -->
        <div class="card">
            <h2 class="card-title best">Common JWT Attacks & Prevention</h2>
            
            <h4>1. Algorithm Confusion Attack</h4>
            <div class="code-block">
// ‚ùå VULNERABLE - Accepting unsigned tokens
jwt.verify(token, secret, (err, decoded) => {
  // If token has { "alg": "none" }, it will pass!
});

// ‚úÖ SECURE - Specify allowed algorithms
jwt.verify(token, secret, {
  algorithms: ['HS256', 'RS256'] // Whitelist specific algorithms
});
            </div>
            
            <h4>2. Weak Secret Attack</h4>
            <div class="code-block">
// ‚ùå INSECURE - Weak secret
const weakSecret = 'secret123';
jwt.sign(payload, weakSecret);

// ‚úÖ SECURE - Strong, random secret
const strongSecret = crypto.randomBytes(64).toString('hex');
// Or use environment variable
const secret = process.env.JWT_SECRET;
            </div>
            
            <h4>3. Kid Injection Attack</h4>
            <div class="danger">
                <strong>Attack:</strong> JWT header can contain a "kid" (key ID) parameter. If the server uses this to select the verification key, an attacker could point to a file they control.
            </div>
            
            <div class="code-block">
// ‚úÖ PREVENTION - Validate kid values
function verifyToken(token) {
  const decoded = jwt.decode(token, { complete: true });
  
  // Validate kid against whitelist
  const validKids = ['key1', 'key2', 'key3'];
  if (!validKids.includes(decoded.header.kid)) {
    throw new Error('Invalid key ID');
  }
  
  // Get key based on kid
  const key = getKey(decoded.header.kid);
  return jwt.verify(token, key);
}
            </div>
        </div>
        
        <!-- Refresh Token Implementation -->
        <div class="demo-area">
            <h3>üîÑ Secure Refresh Token Implementation</h3>
            
            <div class="code-block">
// refresh-token-service.js
class RefreshTokenService {
  constructor() {
    this.refreshTokens = new Map(); // jti ‚Üí token data
  }
  
  // Generate and store refresh token
  async createRefreshToken(userId, userAgent, ip) {
    const jti = crypto.randomBytes(16).toString('hex');
    const token = crypto.randomBytes(32).toString('hex');
    
    const tokenData = {
      userId,
      jti,
      tokenHash: this.hashToken(token),
      userAgent,
      ip,
      createdAt: new Date(),
      expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days
      isActive: true,
      lastUsed: new Date()
    };
    
    // Store in database
    await this.storeToken(tokenData);
    
    return { jti, token };
  }
  
  // Validate refresh token with rotation
  async validateAndRotate(oldToken, jti, userAgent, ip) {
    // Get token from database
    const tokenData = await this.getToken(jti);
    
    if (!tokenData || !tokenData.isActive) {
      throw new Error('Invalid refresh token');
    }
    
    // Check expiration
    if (new Date() > tokenData.expiresAt) {
      await this.revokeToken(jti);
      throw new Error('Refresh token expired');
    }
    
    // Verify token hash
    if (tokenData.tokenHash !== this.hashToken(oldToken)) {
      // Possible theft - revoke all user tokens
      await this.revokeAllUserTokens(tokenData.userId);
      throw new Error('Token validation failed');
    }
    
    // Check for suspicious activity
    if (tokenData.userAgent !== userAgent || tokenData.ip !== ip) {
      // Different device/location - require reauthentication
      await this.revokeToken(jti);
      throw new Error('Suspicious activity detected');
    }
    
    // Create new refresh token (rotation)
    const newToken = await this.createRefreshToken(
      tokenData.userId, 
      userAgent, 
      ip
    );
    
    // Revoke old token
    await this.revokeToken(jti);
    
    return newToken;
  }
  
  // Revoke specific token
  async revokeToken(jti) {
    await db.refreshTokens.update(
      { isActive: false, revokedAt: new Date() },
      { where: { jti } }
    );
  }
  
  // Revoke all tokens for user (password change, logout all)
  async revokeAllUserTokens(userId) {
    await db.refreshTokens.update(
      { isActive: false, revokedAt: new Date() },
      { where: { userId } }
    );
  }
  
  // Hash token for storage (never store plain tokens)
  hashToken(token) {
    return crypto
      .createHash('sha256')
      .update(token)
      .digest('hex');
  }
}
            </div>
            
            <div class="success" style="margin-top: 1rem;">
                <strong>‚úÖ Refresh Token Security Features:</strong>
                <ul>
                    <li>Token rotation (new token on each refresh)</li>
                    <li>Hash storage (never store plain tokens)</li>
                    <li>Device/location binding</li>
                    <li>Theft detection and automatic revocation</li>
                    <li>Individual token revocation</li>
                    <li>Mass revocation capability</li>
                </ul>
            </div>
        </div>
        
        <!-- Final Implementation Summary -->
        <div class="card">
            <h2 class="card-title alternatives">Implementation Summary</h2>
            
            <h4>Complete Secure Authentication Flow:</h4>
            
            <div class="code-block">
// Complete authentication flow with JWT
// 1. User logs in with credentials
POST /api/auth/login
{
  "email": "user@example.com",
  "password": "securepassword"
}

// Response: Access token in JSON, refresh token in HttpOnly cookie
{
  "accessToken": "eyJ...",
  "user": { "id": 1, "email": "user@example.com" }
}
// Set-Cookie: refreshToken=abc123; HttpOnly; Secure; SameSite=Strict

// 2. Access protected resources
GET /api/protected
Authorization: Bearer eyJ...

// 3. Token expires, refresh using refresh token
POST /api/auth/refresh
// Refresh token automatically sent via cookie

// Response: New access token
{
  "accessToken": "eyJ...",
  "expiresIn": 900
}

// 4. User logs out
POST /api/auth/logout
// Server blacklists access token JTI
// Clears refresh token cookie
// Optionally revokes refresh token from database
            </div>
            
            <h4>Security Checklist for Production:</h4>
            
            <div class="form-demo" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.5rem; margin-top: 1rem;">
                <div class="demo-form">
                    <h4>Token Configuration</h4>
                    <ul class="step-list">
                        <li>‚úÖ Use strong signing algorithms (HS256/RS256)</li>
                        <li>‚úÖ Set short access token expiration (5-15 min)</li>
                        <li>‚úÖ Implement refresh token rotation</li>
                        <li>‚úÖ Include jti claim for individual revocation</li>
                        <li>‚úÖ Validate issuer and audience</li>
                    </ul>
                </div>
                
                <div class="demo-form">
                    <h4>Storage & Transmission</h4>
                    <ul class="step-list">
                        <li>‚úÖ Store refresh tokens in HttpOnly cookies</li>
                        <li>‚úÖ Use Secure flag for production</li>
                        <li>‚úÖ Implement SameSite attribute</li>
                        <li>‚úÖ Never store sensitive data in JWT payload</li>
                        <li>‚úÖ Use HTTPS for all token transmission</li>
                    </ul>
                </div>
                
                <div class="demo-form">
                    <h4>Security Features</h4>
                    <ul class="step-list">
                        <li>‚úÖ Implement token blacklist for logout</li>
                        <li>‚úÖ Detect and prevent token reuse</li>
                        <li>‚úÖ Monitor for suspicious activity</li>
                        <li>‚úÖ Provide user session management</li>
                        <li>‚úÖ Regular security audits</li>
                    </ul>
                </div>
            </div>
        </div>
        
                <footer>
                <!-- Primeira linha: Refer√™ncia ao curso -->
                <p style="margin-bottom: 0.5rem;">
                    <strong>Based on "Introduction to JavaScript Security (LFS184)" by The Linux Foundation</strong>
                </p>
                
                <!-- Segunda linha: Informa√ß√µes de licen√ßa e autoria -->
                <p style="margin-bottom: 1rem; font-size: 0.95rem;">
                    Security education reference ‚Ä¢ Created for learning and demonstration purposes ‚Ä¢ Licensed under 
                    <a href="https://creativecommons.org/licenses/by-sa/4.0/" 
                    target="_blank" 
                    style="color: #4a6491; text-decoration: none; font-weight: 600;">
                        CC-BY-SA-4.0
                    </a>
                </p>
                
                <!-- Terceira linha: Informa√ß√µes pessoais -->
                <div style="display: flex; justify-content: center; align-items: center; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap;">
                    <span style="color: #4a6491; font-weight: 600;">¬© Iure Castro</span>
                    <span style="color: #666;">‚Ä¢</span>
                    <span>Personal learning portfolio</span>
                    <span style="color: #666;">‚Ä¢</span>
                    <span>All examples for educational use</span>
                </div>
                
                <!-- Quarta linha: Links √∫teis -->
                <div style="display: flex; justify-content: center; gap: 1.5rem; margin: 1rem 0; flex-wrap: wrap;">
                    <a href="https://training.linuxfoundation.org/training/introduction-to-javascript-security-lfs184/" 
                    target="_blank"
                    style="color: #4a6491; text-decoration: none; font-size: 0.9rem;">
                        üîó Original Course
                    </a>
                    <a href="https://creativecommons.org/licenses/by-sa/4.0/" 
                    target="_blank"
                    style="color: #4a6491; text-decoration: none; font-size: 0.9rem;">
                        üìÑ CC-BY-SA-4.0 License
                    </a>
                    <a href="certificate.pdf" 
                    target="_blank"
                    style="color: #4a6491; text-decoration: none; font-size: 0.9rem;">
                        üèÜ My Certificate
                    </a>
                </div>
        </footer>
    </div>

    <script>
        // JWT visualization demo
        function decodeJWT() {
            const jwtInput = document.getElementById('jwt-input').value;
            const output = document.getElementById('jwt-output');
            
            if (!jwtInput) {
                output.innerHTML = '<div class="warning">Please enter a JWT token</div>';
                return;
            }
            
            try {
                const parts = jwtInput.split('.');
                if (parts.length !== 3) {
                    throw new Error('Invalid JWT format');
                }
                
                const header = JSON.parse(atob(parts[0].replace(/-/g, '+').replace(/_/g, '/')));
                const payload = JSON.parse(atob(parts[1].replace(/-/g, '+').replace(/_/g, '/')));
                
                output.innerHTML = `
                    <div class="jwt-visualization">
                        <div class="jwt-part jwt-header">
                            <strong>Header</strong><br>
                            <small>${JSON.stringify(header, null, 2)}</small>
                        </div>
                        <div class="jwt-part jwt-payload">
                            <strong>Payload</strong><br>
                            <small>${JSON.stringify(payload, null, 2)}</small>
                        </div>
                        <div class="jwt-part jwt-signature">
                            <strong>Signature</strong><br>
                            <small>${parts[2].substring(0, 30)}...</small>
                        </div>
                    </div>
                    
                    <div class="info" style="margin-top: 1rem;">
                        <strong>Security Analysis:</strong><br>
                        ‚Ä¢ Algorithm: ${header.alg || 'Not specified'}<br>
                        ‚Ä¢ Expiration: ${payload.exp ? new Date(payload.exp * 1000).toLocaleString() : 'Not set'}<br>
                        ‚Ä¢ Issuer: ${payload.iss || 'Not specified'}<br>
                        ‚Ä¢ JTI: ${payload.jti ? 'Present ‚úì' : 'Missing ‚ö†Ô∏è'}
                    </div>
                `;
            } catch (error) {
                output.innerHTML = `<div class="danger">Error decoding JWT: ${error.message}</div>`;
            }
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Set example JWT
            document.getElementById('jwt-input').value = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c';
            decodeJWT();
            
            console.log(`
            JWT Security Guide - Key Takeaways:
            
            1. ALWAYS validate JWT signature and algorithm
            2. Use short-lived access tokens (5-15 minutes)
            3. Implement refresh token rotation
            4. Store refresh tokens in HttpOnly cookies
            5. Include jti claim for individual token revocation
            6. Never store sensitive data in JWT payload
            7. Validate issuer and audience claims
            8. Use strong, random secrets or RSA keys
            
            Remember: JWT is a tool, not a security solution by itself!
            `);
        });
    </script>
    
    <!-- Prism.js for syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
</body>
</html>